doctype html
html
  head
    meta(charset='utf-8')
    title AStar Grid
    style.

      #toolbar {
        padding-bottom: 8px;
      }

    script(src='../src/Bu.dev.js')
    script(src='./lib/a-star/AStar.js')
    script(src='./lib/a-star/Node.js')
    script(src='./lib/a-star/Engine.js')
    script(src='./lib/a-star/NetGrid.js')
    script.

      // net info
      var START_POS = {x: 2, y: 5};
      var END_POS = {x: 17, y: 5};

      // rendering config
      var MARGIN = 40.5;
      var GRID_SIZE = 40;
      var GAP_SIZE = 4;
      var OFFSET = GRID_SIZE + GAP_SIZE;

      // components
      var net = new AStar.NetGrid();
      var engine = new AStar.Engine(net);
      net.engine = engine;

      // Renderer
      var renderer;

      // shapes
      var rectRows = [];
      var lineRows = [];
      var labelGRows = [];
      var labelHRows = [];
      var labelFRows = [];
      var axisTextX = [];
      var axisTextY = [];

      // interactive
      var isMouseDown = false;
      var isClearing;

      $.ready(init);


      function init() {

        // set the map
        net.setStart(START_POS.x, START_POS.y);
        net.setEnd(END_POS.x, END_POS.y);

        // append dom
        renderer = new Bu.Renderer({
          container: document.body,
          border: true,
          showKeyPoints: false,
          width: OFFSET * net.width + MARGIN * 2,
          height: OFFSET * net.height + MARGIN * 2
        });
        renderer.dom.addEventListener("mousedown", onMouseDown);
        renderer.dom.addEventListener("mousemove", onMouseMove);
        renderer.dom.addEventListener("mouseup", onMouseUp);

        // bind events
        $("#btnRun").on("click", function () {
          engine.run();
        });
        $("#btnRunSlowly").on("click", function () {
          engine.run(10);
        });
        $("#btnNextStep").on("click", function () {
          engine.step();
        });

        var i, j;
        var xCount = net.width;
        var yCount = net.height;

        // add grid hexagons
        for (i = 0; i < xCount; i++) {
          rectRows[i] = [];
          for (j = 0; j < yCount; j++) {
            rectRows[i][j] = new Bu.Rectangle(
                    MARGIN + OFFSET * i,
                    MARGIN + OFFSET * j,
                    GRID_SIZE,
                    GRID_SIZE
            );
            renderer.append(rectRows[i][j]);
          }
        }

        // add grid path lines
        for (i = 0; i < xCount; i++) {
          lineRows[i] = [];
          for (j = 0; j < yCount; j++) {
            lineRows[i][j] = new Bu.Line(
                    MARGIN + OFFSET * i + GRID_SIZE / 2,
                    MARGIN + OFFSET * j + GRID_SIZE / 2,
                    MARGIN + OFFSET * i + GRID_SIZE / 2,
                    MARGIN + OFFSET * j + GRID_SIZE / 2
            );
            //lineRows[i][j].stroke("rgba(0, 128, 255, 0.5");
            lineRows[i][j].lineWidth = 0.5;
            renderer.append(lineRows[i][j]);
          }
        }

        // add grid labels
        for (i = 0; i < xCount; i++) {
          labelGRows[i] = [];
          labelHRows[i] = [];
          labelFRows[i] = [];

          for (j = 0; j < yCount; j++) {
            labelGRows[i][j] = new Bu.PointText("",
                    MARGIN + OFFSET * i + 2,
                    MARGIN + OFFSET * j + GRID_SIZE - 2,
                    {align: "+-"}
            );
            labelHRows[i][j] = new Bu.PointText("",
                    MARGIN + OFFSET * i + GRID_SIZE - 2,
                    MARGIN + OFFSET * j + GRID_SIZE - 2,
                    {align: "--"}
            );
            labelFRows[i][j] = new Bu.PointText("",
                    MARGIN + OFFSET * i + GRID_SIZE / 2,
                    MARGIN + OFFSET * j + 2,
                    {align: "0+"}
            );

            labelGRows[i][j].fillStyle =
                    labelHRows[i][j].fillStyle = "#666";
            labelGRows[i][j].fontFamily =
                    labelHRows[i][j].fontFamily =
                            labelFRows[i][j].fontFamily = "SimSun";
            renderer.append(labelGRows[i][j]);
            renderer.append(labelHRows[i][j]);
            renderer.append(labelFRows[i][j]);
            refreshNode(i, j);
          }
        }

        // add axis labels
        for (i = 0; i < xCount; i++) {
          axisTextX[i] = new Bu.PointText(
                  i + 1,
                  MARGIN + OFFSET * i + GRID_SIZE / 2,
                  MARGIN / 2
          );
          renderer.append(axisTextX[i]);
        }
        for (i = 0; i < yCount; i++) {
          axisTextY[i] = new Bu.PointText(
                  i + 1,
                  MARGIN / 2,
                  MARGIN + OFFSET * i + GRID_SIZE / 2
          );
          renderer.append(axisTextY[i]);
        }

        engine.on("nodeChanged", function (e) {
          refreshNode(e.x, e.y);
        });

        engine.on("noSolution", function (e) {
          alert("no solution!");
        });

      }

      function refreshNode(i, j) {
        var node = net.getNode(i, j);

        var hexagon = rectRows[i][j];
        hexagon.strokeStyle = "gray";
        hexagon.fillStyle = AStar.getStateColor(node.state);

        // draw path with prevNode
        if (node.prevNode) {
          var x = MARGIN + node.prevNode.position.x * OFFSET + GRID_SIZE / 2;
          var y = MARGIN + node.prevNode.position.y * OFFSET + GRID_SIZE / 2;
          lineRows[i][j].setPoint2(new Bu.Point(x, y));
        }

        // set shortest path lineWidth
        if (node.state == AStar.NODE_STATE_SHORTEST || node.state == AStar.NODE_STATE_END)
          lineRows[i][j].lineWidth = 5;

        // set text
        if (node.state != AStar.NODE_STATE_OBSTACLE && node.state != AStar.NODE_STATE_DEFAULT) {
          labelGRows[i][j].text = Math.round(node.g * 10);
          labelHRows[i][j].text = Math.round(node.h * 10);
          labelFRows[i][j].text = Math.round(node.f() * 10);
        }
      }

      function pixelToIndexX(x, y) {
        return parseInt((x - MARGIN) / OFFSET)
      }

      function pixelToIndexY(x, y) {
        return parseInt((y - MARGIN) / OFFSET)
      }

      function onMouseDown(e) {
        e = renderer.processArgs(e);

        var x = pixelToIndexX(e.offsetX, e.offsetY);
        var y = pixelToIndexY(e.offsetX, e.offsetY);

        var node = net.getNode(x, y);

        if (e.button == 0) {
          // left button
          if (node.state == AStar.NODE_STATE_DEFAULT) {
            node.state = AStar.NODE_STATE_OBSTACLE;
            isClearing = false;
          }
          else if (node.state == AStar.NODE_STATE_OBSTACLE) {
            node.state = AStar.NODE_STATE_DEFAULT;
            isClearing = true;
          }
          engine.trigger("nodeChanged", node.position);
        } else {
          // right button
          console.log("prevNode", node.prevNode);
        }
        isMouseDown = true;
      }

      function onMouseMove(e) {
        e = renderer.processArgs(e);

        if (isMouseDown && e.button == 0) {

          var x = pixelToIndexX(e.offsetX, e.offsetY);
          var y = pixelToIndexY(e.offsetX, e.offsetY);

          var node = net.getNode(x, y);

          // left button
          if (isClearing) {
            if (node.state == AStar.NODE_STATE_OBSTACLE)
              node.state = AStar.NODE_STATE_DEFAULT;
          } else {
            if (node.state == AStar.NODE_STATE_DEFAULT)
              node.state = AStar.NODE_STATE_OBSTACLE;
          }
          engine.trigger("nodeChanged", node.position);
        }
      }

      function onMouseUp() {
        isMouseDown = false;
      }

  body
    div Click the blocks to add/remove obstacles.
    #toolbar
      button#btnRun Run
      button#btnRunSlowly Run slowly
      button#btnNextStep Next step
