doctype html
html(lang="en")
  head
    meta(charset="utf-8")
    title Delaunay Triangulation
    script(src="js/ClipMeter.min.js")
    script(src="../src/Bu.dev.js")
    style.
      html, body, #container {
        margin: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      #info {
        position: absolute;
        width: 100%;
        text-align: center;
        padding: 8px;
      }
    script(type="text/javascript").

      var POINT_COUNT = 64;
      var LINE_COUNT = 50;

      var renderer;
      var points = [];
      var lines = [];

      $.ready(init);

      function init() {
        renderer = new Bu.Renderer({
          container: "#container",
          fillParent: true
        });
        generatePoints();
        document.getElementById("btnRandom").onclick = randomLines;
        document.getElementById("btnAll").onclick = allLines;
        document.getElementById("btnNoCross").onclick = noCrossLines;
        document.getElementById("btnDelaunay").onclick = delaunayLines;
      }

      function generatePoints() {
        for (var i = 0; i < POINT_COUNT; i++) {
          var x = Math.rand(20, renderer.width - 40);
          var y = Math.rand(20, renderer.height - 40);
          points[i] = new Bu.Point(x, y);
          points[i].label = i;
          renderer.append(points[i]);
        }
      }

      // generate lines
      function randomLines() {
        lines = [];
        for (var i = 0; i < LINE_COUNT; i++) {
          var p1 = points[Math.floor(Math.rand(POINT_COUNT))];
          var p2 = points[Math.floor(Math.rand(POINT_COUNT))];
          var line = new Bu.Line(p1, p2);
          line.strokeStyle = "#08f";
          lines.push(line);
          renderer.append(line);
        }
      }

      function allLines() {
        lines = [];
        for (var i = 0; i < POINT_COUNT; i++) {
          for (var j = i + 1; j < POINT_COUNT; j++) {
            var line = new Bu.Line(points[i], points[j]);
            line.strokeStyle = "rgba(0, 0, 0, 0.1)";
            lines.push(line);
            renderer.append(line);
          }
        }
      }

      function noCrossLines() {
        lines = [];
        for (var i = 0; i < POINT_COUNT; i++) {
          for (var j = i + 1; j < POINT_COUNT; j++) {
            var line = new Bu.Line(points[i], points[j]);
            line.strokeStyle = "orange";
            if (!isLineCrossWithAny(line, lines)) {
              lines.push(line);
              renderer.append(line);
              // console.log("Add: ", i, j);
            } else {
              // console.log("Not add: ", i, j);
            }
          }
        }
      }

      function delaunayLines() {
        lines = [];
        for (var i = 0; i < POINT_COUNT; i++) {
          for (var j = i + 1; j < POINT_COUNT; j++) {
            lines.push(new Bu.Line(points[i], points[j]));
          }
        }
        for (var i = 0; i < lines.length; i++) {
          while (lineTryKillOthers(lines[i], lines))
            lineTryKillOthers(lines[i], lines);
        }
        for (var i = 0; i < lines.length; i++) {
          lines[i].strokeStyle = "#808";
          renderer.append(lines[i]);
        }
      }

      // geometry algorithm
      function isLineCrossWithAny(line, lines) {
        for (var i = 0; i < lines.length; i++) {
          if (line.isCrossWithLine(lines[i])) {
            // console.log("crossed with line: [" + lineGroup[i].p1.index + " - " + lineGroup[i].p2.index + "]");
            return true;
          }
        }
        return false;
      }

      function lineTryKillOthers(line, lines) {
        // step 1: To see whether itself will be killed
        for (var i = 0; i < lines.length; i++) {
          if (line.isCrossWithLine(lines[i]) && line.length > lines[i].length) {
            // console.log("[" + line.p1.index + "-" + line.p2.index + "] suicide by [" + lines[i].p1.index + "-" + lines[i].p2.index + "]");
            lines.splice(lines.indexOf(line), 1); // willBeenKilled
            return true;
          }
        }
        // console.log("[" + line.p1.index + "-" + line.p2.index + "] killing its crosses.");
        for (var i = 0; i < lines.length; i++) {
          if (line.isCrossWithLine(lines[i])) {
            // console.log("    [" + lines[i].p1.index + "-" + lines[i].p2.index + "] be killing");
            lines.splice(i, 1);
          }
        }
        return false;
      }

body
  div#info
    span Delaunay Triangulation
    br
    button#btnRandom Random
    button#btnAll All
    button#btnNoCross No Cross
    button#btnDelaunay Delaunay
  div#container
